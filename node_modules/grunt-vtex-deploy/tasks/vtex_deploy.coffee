#
# * grunt-vtex-deploy
# * https://github.com/guilherme/grunt-vtex-deploy
# *
# * Copyright (c) 2013 Guilherme Rodrigues
# * Licensed under the MIT license.
#
Intimidate = require("intimidate")
VersionMap = require("version-map")
path = require("path")
dryRun = false

module.exports = (grunt) ->
  utils =
    # Replace a file's content including hostname after src and href
    processContent: (content, host, versionDirectory, options) ->
      if options.src
        content = content.replace(/src="(\.\.\/)?(?!http|\/|\/\/|\#|\&|\'\&)/g, "src=\"//" + host + "/" + versionDirectory)
      if options.href
        content = content.replace(/href="(\.\.\/)?(?!http|\/|\/\/|\#|\&|\'\&|javascript\:void\(0\)\;)/g, "href=\"//" + host + "/" + versionDirectory)
      if options.versionDirectory
        content = content.replace(/VERSION_DIRECTORY/g, versionDirectory)
      return content

    versionName: (options) ->
      "v" + [options.environmentName, options.environmentType, options.buildNumber].join("-")

    # Return the path with product name and version suffix,
    # e.g. "speedbag/v01-03-00-stable-4/recursive/test1"
    versionDirectory: (path, options) ->
      options.product + "/" +  utils.versionName(options) + "/" + path

    # Returns a name complying to the router naming scheme
    containerDirectory: (options) ->
      [options.acronym, options.environmentName, options.buildNumber, options.environmentType].join("-") + "/"

    # All properties must be defined
    isPropertyValid: (property) ->
      property? and property isnt ""

    checkOptions: (options) ->
      # Checks that all required configurations are valid
      Object.keys(options).forEach (key) ->
        value = options[key]
        throw new Error("Invalid option " + key + " with value " + value) unless utils.isPropertyValid(value)

      # Checks S3 options are present
      if not dryRun and not (options.s3Config and options.s3Config.accessKey and options.s3Config.secretKey)
        throw new Error("Invalid s3 configuration file. Check it has both accessKey and secretKey.")

      if options.indexPath and not grunt.file.exists(options.indexPath)
        throw new Error("Invalid indexPath. Does the file exists?")

      if options.whoamiPath and not grunt.file.exists(options.whoamiPath)
        throw new Error("Invalid whoamiPath. Does the file exists?")

      unless pacha?
        throw new Error("pachamama.config file not found in your project root.")

  # Pachamama configuration file.
  pacha = grunt.file.readJSON("pachamama.config")[0]

  # Task defaults
  defaults =
    tempDirectory: "./tmp-deploy/"
    environmentName: process.env["ENVIRONMENT_NAME"]
    environmentType: process.env["ENVIRONMENT_TYPE"]
    requireEnvironmentType: process.env["ENVIRONMENT_TYPE"]
    buildNumber: process.env["BUILD_NUMBER"]
    acronym: pacha.acronym
    product: pacha.product
    bucket: "vtex-io"
    buildDirectory: "build"
    s3ConfigFile: "/home/ubuntu/s3.json"
    whoamiPath: false
    indexPath: false
    indexOnRoot: false
    includeHostname:
      src: true
      href: true
      versionDirectory: true
      hostname: null
      files: []

  grunt.registerMultiTask "vtex_deploy", "Deploy front end apps to the VTEX infrastructure.", ->
    dryRun = grunt.option('dry-run')
    grunt.log.writeln "Starting in dry-run mode." if dryRun

    # Tell grunt we will run asynchronously
    done = @async()
    fileCount = 0

    # Merge task-specific and/or target-specific options with these defaults.
    options = @options(defaults)
    # The options method doesnt account for nested properties, so we must include these defaults by hand.
    for opt in ['src', 'href', 'versionDirectory']
      options.includeHostname[opt] = defaults.includeHostname[opt] if options.includeHostname[opt] is undefined

    if options.requireEnvironmentType isnt options.environmentType
      grunt.log.writeln "Required environment type", options.requireEnvironmentType, "differs from actual environment type", options.environmentType
      grunt.log.writeln "Stopping"
      return done()

    options.s3Config = if dryRun then {accessKey: '1234', secretKey: '1234'} else require(options.s3ConfigFile)

    # If there is a "whoami" file in the root folder,
    # this project needs to be deployed in a container for the router.
    uploadContainer = options.indexPath and options.whoamiPath

    utils.checkOptions(options)

    # Create a S3 Client with the given options
    intimidate = new Intimidate(
      key: options.s3Config.accessKey
      secret: options.s3Config.secretKey
      bucket: options.bucket
      maxRetries: 5
      backoffInterval: 20
    )

    versionMap = new VersionMap(
      key: options.s3Config.accessKey
      secret: options.s3Config.secretKey
      bucket: options.bucket
    )
    
    ###
    COPY AND COUNT FILES
    We copy files so we can safely manipulate them
    ###
    grunt.log.writeln "Using temp directory:", options.tempDirectory
    if grunt.file.exists(options.tempDirectory) and not dryRun
      grunt.log.writeln "Cleaning temp directory..."
      grunt.file.delete(options.tempDirectory)
    grunt.log.writeln "Copying files to temp directory..."
    grunt.file.recurse options.buildDirectory, (abspath, rootdir) ->
      fileCount++
      grunt.file.copy(abspath, path.join(options.tempDirectory, abspath))

    if options.indexPath and not grunt.file.exists(path.join(options.tempDirectory, options.indexPath))
      fileCount++
      grunt.file.copy(options.indexPath, path.join(options.tempDirectory, options.indexPath))

    if options.whoamiPath and not grunt.file.exists(path.join(options.tempDirectory, options.whoamiPath))
      fileCount++
      grunt.file.copy(options.whoamiPath, path.join(options.tempDirectory, options.whoamiPath))

    grunt.log.writeln "Copied", fileCount, "files"

    ###
    CONTENT REPLACEMENT
    Replace src= and href= in index files if needed, to include a hostname.
    ###
    if options.includeHostname and options.includeHostname.hostname and options.includeHostname.files
      grunt.log.writeln()
      grunt.log.writeln "Starting preprocessing"
      grunt.log.writeln "Files:", options.includeHostname.files
      for file in options.includeHostname.files
        tempPath = path.join(options.tempDirectory, file)
        modifiedContent = utils.processContent(grunt.file.read(tempPath), options.includeHostname.hostname, utils.versionDirectory('', options), options.includeHostname)
        grunt.file.write(tempPath, modifiedContent)
        grunt.log.writeln "Processed", tempPath

    ###
    UPLOAD TO S3
    ###
    grunt.log.writeln()
    grunt.log.writeln "Using bucket: #{options.bucket}"
    grunt.log.writeln "Application upload path: #{utils.versionDirectory("", options)}"

    files = []

    # Add every file at it's version folder.
    grunt.file.recurse path.join(options.tempDirectory, options.buildDirectory), (abspath, rootdir) ->
      targetPath = utils.versionDirectory(abspath.replace(rootdir, ""), options).replace("//", "/")
      files.push {src: abspath, dest: targetPath}

    if options.indexPath and options.indexOnRoot
      # Upload latest index to product root
      files.push {src: path.join(options.tempDirectory, options.indexPath), dest: options.product + "/index.html"}

    ###
    WHOAMI
    This section is used by apps that need an address
    on the store host, e.g. www.store.com.br/admin/speedbag
    It allows us to deploy a container with an index file
    ###
    if uploadContainer
      version = utils.containerDirectory(options)

      grunt.log.writeln "Container upload path: #{version}"

      # Upload index to s3
      files.push {src: path.join(options.tempDirectory, options.indexPath), dest: version + "index.html"}
      
      # If index.debug.html is available, upload it also.
      indexDebugPath = options.indexPath.replace(".html", ".debug.html")
      if grunt.file.exists indexDebugPath
        files.push {src: path.join(options.tempDirectory, indexDebugPath), dest: version + "index.debug.html"}
        
      # Upload whoami to s3
      files.push {src: path.join(options.tempDirectory, options.whoamiPath), dest: version + "meta/whoami"}

    if dryRun
      grunt.log.writeln()
      for file in files
        grunt.log.writeln "Would upload https://#{options.bucket}.s3.amazonaws.com/#{file.dest}"
      done()
    else
      intimidate.uploadFiles files, (err, res) ->
        if err
          console.error "Error uploading files"
          throw err
        else
          grunt.log.writeln "Uploaded all files successfully!"
          grunt.log.writeln "List of uploaded files:"
          for file in files
            grunt.log.writeln "https://#{options.bucket}.s3.amazonaws.com/#{file.dest}"

          grunt.log.writeln "Updating version map..."

          versionMap.updateVersion options.environmentType, options.product, utils.versionName(options), (err, versionMap) ->
            throw err if err
            grunt.log.writeln versionMap
            done()