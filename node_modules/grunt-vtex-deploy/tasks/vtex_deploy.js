(function() {
  var Intimidate, VersionMap, dryRun, path;

  Intimidate = require("intimidate");

  VersionMap = require("version-map");

  path = require("path");

  dryRun = false;

  module.exports = function(grunt) {
    var defaults, pacha, utils;
    utils = {
      processContent: function(content, host, versionDirectory, options) {
        if (options.src) {
          content = content.replace(/src="(\.\.\/)?(?!http|\/|\/\/|\#|\&|\'\&)/g, "src=\"//" + host + "/" + versionDirectory);
        }
        if (options.href) {
          content = content.replace(/href="(\.\.\/)?(?!http|\/|\/\/|\#|\&|\'\&|javascript\:void\(0\)\;)/g, "href=\"//" + host + "/" + versionDirectory);
        }
        if (options.versionDirectory) {
          content = content.replace(/VERSION_DIRECTORY/g, versionDirectory);
        }
        return content;
      },
      versionName: function(options) {
        return "v" + [options.environmentName, options.environmentType, options.buildNumber].join("-");
      },
      versionDirectory: function(path, options) {
        return options.product + "/" + utils.versionName(options) + "/" + path;
      },
      containerDirectory: function(options) {
        return [options.acronym, options.environmentName, options.buildNumber, options.environmentType].join("-") + "/";
      },
      isPropertyValid: function(property) {
        return (property != null) && property !== "";
      },
      checkOptions: function(options) {
        Object.keys(options).forEach(function(key) {
          var value;
          value = options[key];
          if (!utils.isPropertyValid(value)) {
            throw new Error("Invalid option " + key + " with value " + value);
          }
        });
        if (!dryRun && !(options.s3Config && options.s3Config.accessKey && options.s3Config.secretKey)) {
          throw new Error("Invalid s3 configuration file. Check it has both accessKey and secretKey.");
        }
        if (options.indexPath && !grunt.file.exists(options.indexPath)) {
          throw new Error("Invalid indexPath. Does the file exists?");
        }
        if (options.whoamiPath && !grunt.file.exists(options.whoamiPath)) {
          throw new Error("Invalid whoamiPath. Does the file exists?");
        }
        if (typeof pacha === "undefined" || pacha === null) {
          throw new Error("pachamama.config file not found in your project root.");
        }
      }
    };
    pacha = grunt.file.readJSON("pachamama.config")[0];
    defaults = {
      tempDirectory: "./tmp-deploy/",
      environmentName: process.env["ENVIRONMENT_NAME"],
      environmentType: process.env["ENVIRONMENT_TYPE"],
      requireEnvironmentType: process.env["ENVIRONMENT_TYPE"],
      buildNumber: process.env["BUILD_NUMBER"],
      acronym: pacha.acronym,
      product: pacha.product,
      bucket: "vtex-io",
      buildDirectory: "build",
      s3ConfigFile: "/home/ubuntu/s3.json",
      whoamiPath: false,
      indexPath: false,
      indexOnRoot: false,
      includeHostname: {
        src: true,
        href: true,
        versionDirectory: true,
        hostname: null,
        files: []
      }
    };
    return grunt.registerMultiTask("vtex_deploy", "Deploy front end apps to the VTEX infrastructure.", function() {
      var done, file, fileCount, files, indexDebugPath, intimidate, modifiedContent, opt, options, tempPath, uploadContainer, version, versionMap, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      dryRun = grunt.option('dry-run');
      if (dryRun) {
        grunt.log.writeln("Starting in dry-run mode.");
      }
      done = this.async();
      fileCount = 0;
      options = this.options(defaults);
      _ref = ['src', 'href', 'versionDirectory'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        opt = _ref[_i];
        if (options.includeHostname[opt] === void 0) {
          options.includeHostname[opt] = defaults.includeHostname[opt];
        }
      }
      if (options.requireEnvironmentType !== options.environmentType) {
        grunt.log.writeln("Required environment type", options.requireEnvironmentType, "differs from actual environment type", options.environmentType);
        grunt.log.writeln("Stopping");
        return done();
      }
      options.s3Config = dryRun ? {
        accessKey: '1234',
        secretKey: '1234'
      } : require(options.s3ConfigFile);
      uploadContainer = options.indexPath && options.whoamiPath;
      utils.checkOptions(options);
      intimidate = new Intimidate({
        key: options.s3Config.accessKey,
        secret: options.s3Config.secretKey,
        bucket: options.bucket,
        maxRetries: 5
      });
      versionMap = new VersionMap({
        key: options.s3Config.accessKey,
        secret: options.s3Config.secretKey,
        bucket: options.bucket
      });
      /*
      COPY AND COUNT FILES
      We copy files so we can safely manipulate them
      */

      grunt.log.writeln("Using temp directory:", options.tempDirectory);
      if (grunt.file.exists(options.tempDirectory) && !dryRun) {
        grunt.log.writeln("Cleaning temp directory...");
        grunt.file["delete"](options.tempDirectory);
      }
      grunt.log.writeln("Copying files to temp directory...");
      grunt.file.recurse(options.buildDirectory, function(abspath, rootdir) {
        fileCount++;
        return grunt.file.copy(abspath, path.join(options.tempDirectory, abspath));
      });
      if (options.indexPath && !grunt.file.exists(path.join(options.tempDirectory, options.indexPath))) {
        fileCount++;
        grunt.file.copy(options.indexPath, path.join(options.tempDirectory, options.indexPath));
      }
      if (options.whoamiPath && !grunt.file.exists(path.join(options.tempDirectory, options.whoamiPath))) {
        fileCount++;
        grunt.file.copy(options.whoamiPath, path.join(options.tempDirectory, options.whoamiPath));
      }
      grunt.log.writeln("Copied", fileCount, "files");
      /*
      CONTENT REPLACEMENT
      Replace src= and href= in index files if needed, to include a hostname.
      */

      if (options.includeHostname && options.includeHostname.hostname && options.includeHostname.files) {
        grunt.log.writeln();
        grunt.log.writeln("Starting preprocessing");
        grunt.log.writeln("Files:", options.includeHostname.files);
        _ref1 = options.includeHostname.files;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          file = _ref1[_j];
          tempPath = path.join(options.tempDirectory, file);
          modifiedContent = utils.processContent(grunt.file.read(tempPath), options.includeHostname.hostname, utils.versionDirectory('', options), options.includeHostname);
          grunt.file.write(tempPath, modifiedContent);
          grunt.log.writeln("Processed", tempPath);
        }
      }
      /*
      UPLOAD TO S3
      */

      grunt.log.writeln();
      grunt.log.writeln("Using bucket: " + options.bucket);
      grunt.log.writeln("Application upload path: " + (utils.versionDirectory("", options)));
      files = [];
      grunt.file.recurse(path.join(options.tempDirectory, options.buildDirectory), function(abspath, rootdir) {
        var targetPath;
        targetPath = utils.versionDirectory(abspath.replace(rootdir, ""), options).replace("//", "/");
        return files.push({
          src: abspath,
          dest: targetPath
        });
      });
      if (options.indexPath && options.indexOnRoot) {
        files.push({
          src: path.join(options.tempDirectory, options.indexPath),
          dest: options.product + "/index.html"
        });
      }
      /*
      WHOAMI
      This section is used by apps that need an address
      on the store host, e.g. www.store.com.br/admin/speedbag
      It allows us to deploy a container with an index file
      */

      if (uploadContainer) {
        version = utils.containerDirectory(options);
        grunt.log.writeln("Container upload path: " + version);
        files.push({
          src: path.join(options.tempDirectory, options.indexPath),
          dest: version + "index.html"
        });
        indexDebugPath = options.indexPath.replace(".html", ".debug.html");
        if (grunt.file.exists(indexDebugPath)) {
          files.push({
            src: path.join(options.tempDirectory, indexDebugPath),
            dest: version + "index.debug.html"
          });
        }
        files.push({
          src: path.join(options.tempDirectory, options.whoamiPath),
          dest: version + "meta/whoami"
        });
      }
      if (dryRun) {
        grunt.log.writeln();
        for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
          file = files[_k];
          grunt.log.writeln("Would upload https://" + options.bucket + ".s3.amazonaws.com/" + file.dest);
        }
        return done();
      } else {
        return intimidate.uploadFiles(files, function(err, res) {
          var _l, _len3;
          if (err) {
            throw new Error("Error uploading file:", err);
          } else {
            grunt.log.writeln("Uploaded all files successfully!");
            grunt.log.writeln("List of uploaded files:");
            for (_l = 0, _len3 = files.length; _l < _len3; _l++) {
              file = files[_l];
              grunt.log.writeln("https://" + options.bucket + ".s3.amazonaws.com/" + file.dest);
            }
            grunt.log.writeln("Updating version map...");
            return versionMap.updateVersion(options.environmentType, options.product, utils.versionName(options), function(err, versionMap) {
              if (err) {
                throw err;
              }
              grunt.log.writeln(versionMap);
              return done();
            });
          }
        });
      }
    });
  };

}).call(this);
